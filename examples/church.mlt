# church encoding ruleset for mlatu
# inspired by https://www.youtube.com/watch?v=TcveznrwYtk

# here, a church-encoded value V is the first class quote, and to invoke it, you need V<
# in joy's schemes, a data type V is a function, NOT a quote, meaning that V would invoke it, and (V) would represent the first class version
# here is a handy table that I made:
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# language:  | style:  | call with arg x: | pass to function f:
# mlatu      | postfix | x V<             | V f
# joy-like   | postfix | x V              | (V) f
# LC/CL      | prefix  | V x              | f V
# lisp       | prefix  | (V x)            | (f V)
# imperative | prefix  | V(x)             | f(V)

# church booleans:
# (a) (b) true <  |->  (a)
# (a) (b) false<  |->  (b)
true  = (-).
false = (~-).
not   = (~)~,.
and   = +<.
or    = +swapd<.
xor   = (~)~()~<~,.


# church pairs:
# (f) (a) (b) cons<  |->  (a) (b) f
# (a) (b) cons       |->  ( ((a) (b)) ~ (<) dip < )
cons = ~>~>,>(~(<)dip<),.
car  = ( -)~<.
cdr  = (~-)~<.


# church numbers:
#   (f) 3<   |->   (f f f)
# x (f) 3<<  |->  x f f f
succ = (+)~,(,),.
pred = (()~(+))~+(<--()),~(,)~<,,.
add  = (succ)~<<.
add2 = (~),(+)~,~(,),,. # GNU's definition
sub  = (pred)~<<.
mul  = ,.
exp  = <.
sqr  = +mul.
0 = (-()). 1 = 0 succ. 2 = 1 succ. 3 = 2 succ. 4 = 3 succ. 5 = 4 succ. 6 = 5 succ. 7 = 6 succ. 8 = 7 succ. 9 = 8 succ. 10 = 9 succ.
100 = 10 10 mul. 1000 = 100 10 mul. 10000 = 100 100 mul.

eq? = (((a))dip)dip (<<)dip (b)~<< Y.
a b = . a Y = N. a N = n. b Y = N. b N = N.

eq0? = ((Y)(-(N)))dip<<<.
